name: Grid E2E (Terraform → Tests → Destroy)

on:
  workflow_dispatch:
    inputs:
      grid_cidrs:
        description: 'CIDRs allowed to access Selenium Grid (4444/7900)'
        required: false
        default: '["0.0.0.0/0"]'
      ssh_cidrs:
        description: 'CIDRs allowed to SSH (22); keep empty in CI'
        required: false
        default: '[]'
  push:
    branches: [ "main" ]
    paths:
      - "iac/**"
      - "src/**"
      - "pom.xml"
      - "testng.xml"
      - ".github/workflows/grid-e2e.yml"

concurrency:
  group: grid-e2e-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: us-east-1
  IAC_DIR: iac

  # Remote state config (set these as repo secrets)
  TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
  TF_STATE_REGION: ${{ secrets.TF_STATE_REGION }}
  TF_STATE_LOCK_TABLE: ${{ secrets.TF_STATE_LOCK_TABLE }}
  TF_STATE_KEY: selforge-grid/${{ github.ref_name }}/terraform.tfstate

jobs:
  terraform_apply:
    name: Terraform Apply (create Grid with remote state)
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      grid_url:  ${{ steps.out.outputs.grid_url }}
      public_ip: ${{ steps.out.outputs.public_ip }}
      novnc_url: ${{ steps.out.outputs.novnc_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS creds (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Bootstrap remote state backend (idempotent)
        run: |
          set -euo pipefail
          if [ -z "${TF_STATE_BUCKET}" ] || [ -z "${TF_STATE_REGION}" ] || [ -z "${TF_STATE_LOCK_TABLE}" ]; then
            echo "ERROR: TF_STATE_BUCKET / TF_STATE_REGION / TF_STATE_LOCK_TABLE must be set as repo secrets." >&2
            exit 1
          fi
          # Create S3 bucket if needed
          if ! aws s3api head-bucket --bucket "${TF_STATE_BUCKET}" 2>/dev/null; then
            if [ "${TF_STATE_REGION}" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "${TF_STATE_BUCKET}" --region "${TF_STATE_REGION}"
            else
              aws s3api create-bucket --bucket "${TF_STATE_BUCKET}" --region "${TF_STATE_REGION}" \
                --create-bucket-configuration LocationConstraint="${TF_STATE_REGION}"
            fi
            aws s3api put-bucket-versioning --bucket "${TF_STATE_BUCKET}" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "${TF_STATE_BUCKET}" --server-side-encryption-configuration \
              '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
          fi
          # Create DynamoDB lock table if needed
          if ! aws dynamodb describe-table --table-name "${TF_STATE_LOCK_TABLE}" >/dev/null 2>&1; then
            aws dynamodb create-table \
              --table-name "${TF_STATE_LOCK_TABLE}" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region "${TF_STATE_REGION}"
            aws dynamodb wait table-exists --table-name "${TF_STATE_LOCK_TABLE}" --region "${TF_STATE_REGION}"
          fi

      - name: Generate ephemeral SSH key (for EC2 key pair)
        run: |
          ssh-keygen -t ed25519 -N "" -f $RUNNER_TEMP/gha_key
          echo "SSH_PUBLIC_KEY_PATH=$RUNNER_TEMP/gha_key.pub" >> $GITHUB_ENV

      - name: Resolve CIDR inputs
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.ssh_cidrs }}" ]; then
            echo "SSH_CIDRS=${{ github.event.inputs.ssh_cidrs }}" >> $GITHUB_ENV
          else
            echo 'SSH_CIDRS=[]' >> $GITHUB_ENV
          fi
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.grid_cidrs }}" ]; then
            echo "GRID_CIDRS=${{ github.event.inputs.grid_cidrs }}" >> $GITHUB_ENV
          else
            echo 'GRID_CIDRS=["0.0.0.0/0"]' >> $GITHUB_ENV
          fi

      - name: Terraform init (remote backend S3 + DynamoDB)
        working-directory: ${{ env.IAC_DIR }}
        run: |
          terraform init -reconfigure \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${TF_STATE_REGION}" \
            -backend-config="dynamodb_table=${TF_STATE_LOCK_TABLE}" \
            -backend-config="encrypt=true"

      - name: Terraform apply (create infra)
        working-directory: ${{ env.IAC_DIR }}
        run: |
          terraform apply -auto-approve \
            -var="create_key_pair=true" \
            -var="ssh_public_key_path=${SSH_PUBLIC_KEY_PATH}" \
            -var="ssh_cidrs=${SSH_CIDRS}" \
            -var="grid_cidrs=${GRID_CIDRS}"

      - name: Capture Terraform outputs
        id: out
        working-directory: ${{ env.IAC_DIR }}
        run: |
          echo "grid_url=$(terraform output -raw grid_url)"   >> $GITHUB_OUTPUT
          echo "public_ip=$(terraform output -raw public_ip)" >> $GITHUB_OUTPUT
          echo "novnc_url=$(terraform output -raw novnc_url)" >> $GITHUB_OUTPUT

      - name: Echo URLs
        run: |
          echo "Grid:  ${{ steps.out.outputs.grid_url }}"
          echo "noVNC: ${{ steps.out.outputs.novnc_url }}"

  run_tests:
    name: Run Selenium Tests
    runs-on: ubuntu-latest
    needs: terraform_apply
    env:
      GRID_URL:  ${{ needs.terraform_apply.outputs.grid_url }}
      PUBLIC_IP: ${{ needs.terraform_apply.outputs.public_ip }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Needed here because this job calls AWS CLI for waiters and debug
      - name: Configure AWS creds (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Wait for EC2 instance-status-ok (best-effort)
        if: always()
        env:
          PUBLIC_IP: ${{ env.PUBLIC_IP }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e
          if [ -z "$PUBLIC_IP" ]; then
            echo "No public IP from Terraform outputs. Skipping EC2 wait."
            exit 0
          fi
          echo "Looking up instance by public IP: $PUBLIC_IP"
          IID="$(aws ec2 describe-instances --region "$AWS_REGION" \
            --filters "Name=ip-address,Values=$PUBLIC_IP" \
            --query 'Reservations[].Instances[].InstanceId' --output text || true)"
          if [ -n "$IID" ] && [ "$IID" != "None" ]; then
            echo "Found instance: $IID. Waiting for instance-status-ok…"
            aws ec2 wait instance-status-ok --region "$AWS_REGION" --instance-ids "$IID" || true
          else
            echo "Could not resolve instance by IP. Continuing without EC2 waiter."
          fi

      - name: Debug: EC2 + SG details
        if: always()
        env:
          PUBLIC_IP: ${{ env.PUBLIC_IP }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e
          if [ -z "$PUBLIC_IP" ]; then exit 0; fi
          echo "🔎 Looking up instance & SGs for $PUBLIC_IP"
          IID="$(aws ec2 describe-instances --region "$AWS_REGION" \
            --filters "Name=ip-address,Values=$PUBLIC_IP" \
            --query 'Reservations[].Instances[].InstanceId' --output text || true)"
          echo "InstanceId: $IID"
          aws ec2 describe-instances --region "$AWS_REGION" --instance-ids "$IID" \
            --query 'Reservations[].Instances[].{Id:Instances[0].InstanceId, State:Instances[0].State.Name, AZ:Instances[0].Placement.AvailabilityZone, SGs:Instances[0].SecurityGroups[*].GroupId, Subnet:Instances[0].SubnetId, PrivateIp:Instances[0].PrivateIpAddress}' \
            --output table || true
          SGIDS=$(aws ec2 describe-instances --region "$AWS_REGION" --instance-ids "$IID" \
            --query 'Reservations[].Instances[].SecurityGroups[].GroupId' --output text || true)
          for SG in $SGIDS; do
            echo "---- Security Group $SG rules ----"
            aws ec2 describe-security-groups --region "$AWS_REGION" --group-ids "$SG" \
              --query 'SecurityGroups[].{GroupId:GroupId, Ingress:IpPermissions, Egress:IpPermissionsEgress}' \
              --output json | jq . || true
          done

      - name: Debug: show EC2 console/cloud-init output
        if: always()
        env:
          PUBLIC_IP: ${{ env.PUBLIC_IP }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e
          if [ -z "$PUBLIC_IP" ]; then exit 0; fi
          IID="$(aws ec2 describe-instances --region "$AWS_REGION" \
            --filters "Name=ip-address,Values=$PUBLIC_IP" \
            --query 'Reservations[].Instances[].InstanceId' --output text || true)"
          echo "🗒️  Latest EC2 console output for $IID:"
          aws ec2 get-console-output --region "$AWS_REGION" --instance-id "$IID" --latest --output text 2>/dev/null || \
          aws ec2 get-console-output --region "$AWS_REGION" --instance-id "$IID" --output text || true

      - name: Wait for Grid readiness (TCP 4444 + /status)
        env:
          GRID_URL: ${{ env.GRID_URL }}
        run: |
          set -e
          URL="${GRID_URL%/}"
          HOST="${URL#http://}"; HOST="${HOST#https://}"; HOST="${HOST%%:*}"
          echo "Probing $HOST:4444"
          for i in $(seq 1 120); do
            if timeout 2 bash -lc "cat </dev/null > /dev/tcp/$HOST/4444" 2>/dev/null; then
              READY="$(curl -fsS "$URL/status" | jq -r '.value.ready // .ready // empty' || true)"
              if [ "$READY" = "true" ]; then
                echo "✅ Grid is ready."
                exit 0
              fi
              echo "🟡 TCP is open but Grid not ready yet… ($i/120)"
            else
              echo "⛔ Port 4444 not open yet… ($i/120)"
            fi
            sleep 5
          done
          echo "❌ Grid did not become ready in time. Last /status (if any):"
          curl -v "$URL/status" || true
          exit 1

      - name: Build & run tests (Maven)
        env:
          GRID_URL: ${{ env.GRID_URL }}
        run: mvn -B -Dgrid.url="$GRID_URL" test

      - name: Archive TestNG reports (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: |
            target/surefire-reports/**
            target/testng-results.xml
            target/emailable-report.html

  terraform_destroy:
    name: Terraform Destroy (always)
    if: always()
    runs-on: ubuntu-latest
    needs: [terraform_apply, run_tests]
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS creds (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Regenerate ephemeral SSH key (matches var layout)
        run: |
          ssh-keygen -t ed25519 -N "" -f $RUNNER_TEMP/gha_key
          echo "SSH_PUBLIC_KEY_PATH=$RUNNER_TEMP/gha_key.pub" >> $GITHUB_ENV

      - name: Reuse CIDR inputs (same logic)
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.ssh_cidrs }}" ]; then
            echo "SSH_CIDRS=${{ github.event.inputs.ssh_cidrs }}" >> $GITHUB_ENV
          else
            echo 'SSH_CIDRS=[]' >> $GITHUB_ENV
          fi
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.grid_cidrs }}" ]; then
            echo "GRID_CIDRS=${{ github.event.inputs.grid_cidrs }}" >> $GITHUB_ENV
          else
            echo 'GRID_CIDRS=["0.0.0.0/0"]' >> $GITHUB_ENV
          fi

      - name: Terraform init (remote backend)
        working-directory: ${{ env.IAC_DIR }}
        run: |
          terraform init -reconfigure \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${TF_STATE_REGION}" \
            -backend-config="dynamodb_table=${TF_STATE_LOCK_TABLE}" \
            -backend-config="encrypt=true"

      - name: Terraform destroy (cleanup infra)
        working-directory: ${{ env.IAC_DIR }}
        run: |
          terraform destroy -auto-approve \
            -var="create_key_pair=true" \
            -var="ssh_public_key_path=${SSH_PUBLIC_KEY_PATH}" \
            -var="ssh_cidrs=${SSH_CIDRS}" \
            -var="grid_cidrs=${GRID_CIDRS}"
